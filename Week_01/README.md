学习笔记
## 类生命周期加载过程 ##
生命周期7个：加载、校验、准备、解析、初始化、使用、卸载<br>
加载过程5个：加载、校验、准备、解析、初始化<br>
**加载**：找到class文件，不会检查classfile的语法和格式错误。加载的整个过程是JVM和类加载系统共同完成，具体的loading阶段是JVM与某个类加载器一起完成。可能出现NoClassDefFound错误。<br>
**校验**：确保class文件里的字节流信息符合当前虚拟机要求，不会危害虚拟机安全。检查classfile的语义，判断常量池的符号，执行类型检查。可能出现VerifyError、ClassFormatError。<br>
可能涉及加载其他类，某个类的加载过程，JVM必须加载其所有的超类和接口。<br>
**准备**：创建静态字段并初始化为默认值（null或0），并分配方法表，即在方法区中分配这些变量所使用的内存空间，不执行java代码。<br>
**解析**：解析常量池，主要包括：类或接口的解析、字段解析、类方法解析、接口方法解析。<br>
当一个变量引用某个对象时，这个引用在.class文件中是以符号引用存储（相当于索引记录）。解析阶段需要将符号引用解析为直接引用（指向实际对象）。如果有了直接引用，那么引用的目标一定存在堆中。<br>
**初始化**：必须在类的首次主动使用，才执行类的初始化。初始化过程包括：构造方法、static静态变量赋值语句、static静态代码块。如果一个子类进行初始化那么会先对父类进行初始化，保证父类在子类之前初始化。所以在java中初始化一个类，那么必定先初始化过Object类。<br>
## 类加载时机 ##
当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main方法所在的 类； <br>
当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new一个类的时候要初始化；<br>
当遇到调用静态方法的指令时，初始化该静态方法所在的类； 当遇到访问静态字段的指令时，初始化该静态字段所在的类； <br>
子类的初始化会触发父类的初始化； <br>
如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初 始化，会触发该接口的初始化； <br>
使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射 调用要么是已经有实例了，要么是静态方法，都需要初始化； <br>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。
## 类加载机制 ##
类加载器：包括启动类加载器、扩展类加载器、应用类加载器<br>
类加载机制有三个特点：<br>
**双亲委托**：当一个自定义类加载器需要加载一个类，比如java.lang.String，它很 懒，不会一上来就直接试图加载它，而是先委托自己的父加载器去加载，父加载 器如果发现自己还有父加载器，会一直往前找，这样只要上级加载器，比如启动 类加载器已经加载了某个类比如java.lang.String，所有的子加载器都不需要自己 加载了。如果几个类加载器都没有加载到指定名称的类，那么会抛出 ClassNotFountException异常。<br> 
**负责依赖**：如果一个加载器在加载某个类的时候，发现这个类依赖于另外几个类 或接口，也会去尝试加载这些依赖项。<br> 
 **缓存加载**：为了提升加载效率，消除重复加载，一旦某个类被一个类加载器加载，那么它会缓存这个加载结果，不会重复加载。<br>

